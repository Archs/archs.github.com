<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>慎独</title>
    <link>http://www.archs.tk</link>
    <pubDate>2013-05-28 09:29:17 +0800</pubDate>
    <item>
      <title>在TinyCore中取代BusyBox</title>
      <link>http://www.archs.tk/TinyCore/fullpowerTinyCore/</link>
      <pubDate>2013-04-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;TinyCore为了最小化体积，使用BusyBox构建基本的Shell环境，所以不是&#xA;完全的 &lt;code&gt;GNU compatible&lt;/code&gt; ，在编译软件的时候可能造成一定的困扰。如果&#xA;在TinyCore下面编译软件遇到问题，可注意下兼容性问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tce-load -wo coreutils util-linux&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以OnDemand的方式安装 &lt;code&gt;coreutils&lt;/code&gt; 和 &lt;code&gt;util-linux&lt;/code&gt; ，下载必须软件包。&#xA;使用的时候&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tce-load -i coreutils util-linux&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;即可。参见&lt;a href=&#34;http://tinycorelinux.net/faq.html#compatibility&#34;&gt;TinyCore Wiki&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用hg访问git仓库</title>
      <link>http://www.archs.tk/python/hg4git/</link>
      <pubDate>2013-04-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;hg用久了，觉得git命令很别扭，高级功能很少用到，速度差别基本上&#xA;感觉不出来，哈，所以还是hg喽. 唯一的问题就在于Github，它不支持hg。&#xA;好在hg有一个hggit的扩展，有一次感叹一下python的“batter included”！&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;安装前准备&#34; href=&#34;#安装前准备&#34;&gt;&lt;/a&gt;安装前准备&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Linux下面自然不用多说，Windows下面要注意几个问题&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除Mercurial提供的exe或者mis安装过的独立版本&lt;/li&gt;&#xA;&lt;li&gt;安装有Mingw，当然你用msvc的话下面的就可以省略了，&#xA;不过我还没有尝试过&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;设置Python Disutils的默认编译器为Gcc&#xA;进入 &lt;code&gt;PYTHON_HOME/Lib/distutils&lt;/code&gt; 建立新文件 &lt;code&gt;distutils.cfg&lt;/code&gt; 。&#xA;输入以下内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[build]&#xA;compiler=mingw32&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;安装&#34; href=&#34;#安装&#34;&gt;&lt;/a&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装就简单了，使用 &lt;code&gt;easy_install&lt;/code&gt; 或者 &lt;code&gt;pip&lt;/code&gt; 直接&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pip install mercurial&#xA;pip install hg-git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后配置hg加载hggit扩展，在用户目录下的 &lt;code&gt;.hgrc&lt;/code&gt; 文件中加入&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[extensions]&#xA;bookmarks =&#xA;hggit =&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后输入 &lt;code&gt;hg help&lt;/code&gt; 就能看看到hggit已加载的输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;enabled extensions:&#xA;&#xA;hggit         push and pull from a Git server&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用&#34; href=&#34;#使用&#34;&gt;&lt;/a&gt;使用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用的时候就是普遍的hg的命令了，这是相当happy的。&#xA;要注意的是git路径到hggit的转换，比如github中ssh方式访问&#xA;&lt;code&gt;git@github.com:username/reposname.git&lt;/code&gt; 要换成&#xA;&lt;code&gt;git+ssh://git@github.com:username/reposname.git&lt;/code&gt; 就可以了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;还有一个推送已有hg库到git库的方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cd hg-git # (a Mercurial repository)&#xA;$ hg bookmark -r default master # make a bookmark of master for default, so a ref gets created&#xA;$ hg push git+ssh://git@github.com/schacon/hg-git.git&#xA;$ hg push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;enjoy-you-git-now!&#34; href=&#34;#enjoy-you-git-now!&#34;&gt;&lt;/a&gt;Enjoy you Git Now!&lt;/h1&gt;&#xA;</description>
    </item>
    <item>
      <title>Embed ChickenScheme In Go</title>
      <link>http://www.archs.tk/go/goschicken/</link>
      <pubDate>2013-04-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用cgo加载c库的主要麻烦在于cgo不识别c头文件中的宏&#xA;而chicken scheme初始化的时候要调用一个全局函数CHICKEN_default_toplevel。&#xA;在cgo中使用 &lt;code&gt;void* dfp = CHICKEN_default_toplevel;&lt;/code&gt; 可以直接声明。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;/*&#xA;#cgo windows CFLAGS: -D_GUN_SOURCE -I&amp;quot;c:/my-chicken/include/chicken&amp;quot; -DHAVE_CHICKEN_CONFIG_H -DC_ENABLE_PTABLES&#xA;#cgo windows LDFLAGS: -L&amp;quot;c:/my-chicken/lib&amp;quot; -lchicken -lm&#xA;&#xA;#include &amp;lt;chicken.h&amp;gt;&#xA;&#xA;void* dfp = CHICKEN_default_toplevel;&#xA;*/&#xA;import &amp;quot;C&amp;quot;&#xA;import (&#xA;    &amp;quot;unsafe&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src := &amp;quot;(+ 1 2 3)&amp;quot;&#xA;    nSrc := 10&#xA;    ret := make([]byte, nSrc)&#xA;    p := (*C.char)(unsafe.Pointer(&amp;amp;ret[0]))&#xA;    C.CHICKEN_run(C.dfp)&#xA;    C.CHICKEN_eval_string_to_string(C.CString(src), p, C.int(nSrc))&#xA;    println(string(ret))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最近才发现，cgo不仅可以识别注释中的c语句，对于相同目录下面的*.c文件也可&#xA;自动编译，呵呵，像sqlite之类的库就可以静态的形式直接使用了。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Markdown</title>
      <link>http://www.archs.tk/utils/aboutMarkDown/</link>
      <pubDate>2013-03-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;感觉比rst简单许多，链接的使用也没有那么多的麻烦。&#xA;docutils是一个伟大的工具，但是有些 &lt;em&gt;繁琐&lt;/em&gt; 。细节的使用上&#xA;比如插入图片，虽然可以定制格式但是调整起来还是很麻烦的。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;简单的列表&#34; href=&#34;#简单的列表&#34;&gt;&lt;/a&gt;简单的列表&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;关键是列表啊，md的列表很比rst好用一些&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;这是itme1&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可插入一个段落，作为itme1的一个子段落，&#xA;这在rst中让我遇到很多麻烦&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Item2&lt;/p&gt;&#xA;&#xA;&lt;p&gt;rst中的ordered list不能够被自段落分开，否则编号不连续&#xA;最后使用的还是手写编号的形式，就跟md一样了&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;方便的标题&#34; href=&#34;#方便的标题&#34;&gt;&lt;/a&gt;方便的标题&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;标题要简洁一些，而且没有要求下划线至少要不标题长，少了一些约束。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;代码插入&#34; href=&#34;#代码插入&#34;&gt;&lt;/a&gt;代码插入&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;来段代码吧 :)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// New in version 2.6.&#xA;func PyErr_WarnPy3k(message string, stacklevel int) error {&#xA;    c_message := C.CString(message)&#xA;    defer C.free(unsafe.Pointer(c_message))&#xA;&#xA;    return int2err(C._gopy_PyErr_WarnPy3k(c_message, C.int(stacklevel)))&#xA;}&#xA;&#xA;// int PyErr_CheckSignals()&#xA;// This function interacts with Python’s signal handling. It checks whether a signal has been sent to the processes and if so, invokes the corresponding signal handler. If the signal module is supported, this can invoke a signal handler written in Python. In all cases, the default effect for SIGINT is to raise the KeyboardInterrupt exception. If an exception is raised the error indicator is set and the function returns -1; otherwise the function returns 0. The error indicator may or may not be cleared if it was previously set.&#xA;func PyErr_CheckSignals() bool {&#xA;    return int2bool(C.PyErr_CheckSignals())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;markdown跟HTML的紧密结合，使网页的手动写作方便了许多。虽然在多种到处格式上比&#xA;rst还是有些差距，但是用的机会毕竟不多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;想看教程的猛击这里&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown中文版语法说明&lt;/a&gt; :)&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>