<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>慎独</title>
    <link>http://www.archs.tk</link>
    <pubDate>2013-05-29 07:14:38 +0800</pubDate>
    <item>
      <title>DSL的模式和方法</title>
      <link>http://www.archs.tk/程序设计/dsl/</link>
      <pubDate>2013-05-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近研究Lisp，对Domain Specific Language很是产生了一些兴趣。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;James Gosling曾经说过： &lt;code&gt;每个配置文件最终都会变成一门编程语言。&lt;/code&gt; 这大概是&#xA;DSL之所以兴起和引人关注的一点吧。另外Martin Fowler在&lt;a href=&#34;http://book。douban。com/subject/21964984/&#34;&gt;《领域特定语言》&lt;/a&gt;中&#xA;强调了与领域专家的沟通作为DSL的一个主要优点和设计出发点。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;广义的说HTML之于服务后端的业务逻辑实现和。net中XAML对于C#的代码来说都是&#xA;一种具体的DSL，所以说DSL促成了或者达到了UI和业务分离也不为过，这实际上&#xA;可以认为是领域专家（UI设计师）沟通的延伸，但是达成的效果是实实在在的。&#xA;上面举到的两个例子跟XML的关系是非同一般的紧密，同时也说了XML作为DSL载体&#xA;的优势。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;内部和外部DSL&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;大体上讲DSL可以分为两种。Martin Fowler说的第三种语言工作台我不是很理解。&#xA;内部DSL与宿主语言结合紧密，实际上可以认为是宿主语言的特殊形式，这一点可&#xA;能与XML的例子大相径庭，也是我刚接触LISP的时候最困惑的一点：宿主语言自身&#xA;也可以有DSL吗？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://book。douban。com/subject/21964984/&#34;&gt;《领域特定语言》&lt;/a&gt;中定义DSL为：&lt;code&gt;针对某一特定领域，具有受限表达性的一种&#xA;计算机程序设计语言&lt;/code&gt; 。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里如果硬性认定 &lt;strong&gt;计算机程序设计语言&lt;/strong&gt; 的话，那么好多DSL就不能被考虑在内&#xA;了。实际上DSL的定义可以相当 &lt;strong&gt;广泛&lt;/strong&gt; ：具有一定模式的特殊语法形式都可以&#xA;认为DSL的一种，比如Lisper经常会自行定义的特殊语法结构，有的时候只是为了完成&#xA;一部分的功能；再比如Make和Ant都被认为是DSL的典型范例，但是它们作为计算机设&#xA;计语言都是不完备的，不仅不能算作完备，甚至连完整也称不上。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;外部DSL就比较常规了，感觉我们通常说的DSL就是这一种了。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;内部DSL的几种方式&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;看&lt;a href=&#34;http://book。douban。com/subject/21964984/&#34;&gt;《领域特定语言》&lt;/a&gt;比较有收获的一点是关于内部DSL的认识，让我长了不少见识。&#xA;内部DSL可以根据宿主语言的语法特点有针对的构造，方法（不仅仅是函数）、闭包和&#xA;Literal Map都是大有帮助的语法糖，所以在面向对象和动态类型的语言里面实现起来&#xA;都是比较便利的，当然Go也其中哦。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;经典的几种方式：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;表达式生产器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这种方式说是实在的与方法级联的形式差不多，主要在于对原有的命令式接口函数&#xA;的组装。这里说的表达式，就是原来的命令是的接口所谓表达式，应该就是程序&#xA;设计语言中原有的关于表达式的概念。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;方法级联&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这是常见的方式，广为人知的形式应该就是 &lt;strong&gt;jQuery的链式操作&lt;/strong&gt; 了，很经典。不过，&#xA;如果这都算是一种DSL的话，那么DSL的范围应该是十分广泛的。一个方法级联的例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;computer()&#xA;    .processor()&#xA;        .cores(2)&#xA;        .speed(2500)&#xA;        .i386()&#xA;    .disk()&#xA;        .size(150)&#xA;    .dist()&#xA;        .size(75)&#xA;        .speed(7200)&#xA;        .sata()&#xA;    .end()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面这种还好，不过 &lt;strong&gt;jQuery的链式操作&lt;/strong&gt; 中噪杂的信息太多了，&#xA;实际上应该还是专注于宿主语言的使用了。这种形式的API好像是越来越多了，&#xA;&lt;a href=&#34;https://code。google。com/p/google-api-go-client/&#34;&gt;Google API的Go Client&lt;/a&gt;也多少采用了类似的形式。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Literal Map&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这种方式就要借助于宿主语言的实现方式了，支持Literal Map在脚本语言里很常见，&#xA;最近主流的静态类型语言也开始支持了，比如C#和Go。 在Go语言中这是一个很好的&#xA;特性，下面这段代码引自 &lt;em&gt;Go语言的Windows GUI项目&lt;a href=&#34;https://github。com/lxn/walk/blob/master/examples/actions/actions。go&#34;&gt;Walk&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MainWindow{&#xA;AssignTo: &amp;amp;mw。MainWindow，&#xA;Title:    &amp;quot;Walk Actions Example&amp;quot;，&#xA;MenuItems: []MenuItem{&#xA;    Menu{&#xA;        Text: &amp;quot;&amp;amp;File&amp;quot;,&#xA;        Items: []MenuItem{&#xA;            Action{&#xA;                AssignTo:    &amp;amp;openAction,&#xA;                Text:        &amp;quot;&amp;amp;Open&amp;quot;,&#xA;                Image:       &amp;quot;。。/img/open。png&amp;quot;,&#xA;                Enabled:     Bind(&amp;quot;enabledCB。Checked&amp;quot;),&#xA;                Visible:     Bind(&amp;quot;openVisibleCB。Checked&amp;quot;),&#xA;                Shortcut:    Shortcut{walk。ModControl, walk。KeyO},&#xA;                OnTriggered: mw。openAction_Triggered,&#xA;            },&#xA;            Menu{&#xA;                AssignTo: &amp;amp;recentMenu,&#xA;                Text:     &amp;quot;Recent&amp;quot;,&#xA;            },&#xA;            Separator{},&#xA;            Action{&#xA;                Text:        &amp;quot;E&amp;amp;xit&amp;quot;,&#xA;                OnTriggered: func() { walk。App()。Exit(0) },&#xA;            },&#xA;        },&#xA;    },&#xA;    Menu{&#xA;        Text: &amp;quot;&amp;amp;Help&amp;quot;,&#xA;        Items: []MenuItem{&#xA;            Action{&#xA;                AssignTo:    &amp;amp;showAboutBoxAction,&#xA;                Text:        &amp;quot;About&amp;quot;,&#xA;                OnTriggered: mw。showAboutBoxAction_Triggered,&#xA;            },&#xA;        },&#xA;    },&#xA;},&#xA;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这段代码用&lt;a href=&#34;https://github。com/lxn/walk/blob/master/examples/actions/actions。go&#34;&gt;Walk&lt;/a&gt;的说法是 &lt;em&gt;Declarative(声明式)&lt;/em&gt; 的，但是正好使用了&#xA;DSL中Literal Map的形式，其本身也是Go中的Literal Map。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;另外还有 &lt;em&gt;嵌套函数&lt;/em&gt; ， &lt;em&gt;函数序另列&lt;/em&gt; 等形式，前者还好，在函数式编程中颇为常见，&#xA;后者就有点难受了，实现起来要严重的依赖全局变量，想来不是什么好方法吧:)&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;程序中的几种语义模型&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;DSL主要用来是我们的程序更加的 &lt;em&gt;灵活&lt;/em&gt; ， 那么这种灵活的关键是程序中关于语法&#xA;和语义的分离。 在使用DSL的程序中建立语义模型就很关键。 下面罗列几种常见的程序&#xA;语义模型:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;决策表&lt;/li&gt;&#xA;&lt;li&gt;依赖网络&lt;/li&gt;&#xA;&lt;li&gt;产生式规则&lt;/li&gt;&#xA;&lt;li&gt;状态机&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;决策表实际上和状态机有点相似，但是实现起来略为简单一些。 依赖网络用来管理&#xA;大量数据的共生关系，可以想象一下Make中的目标和依赖，一般可以用有向无环图来&#xA;实现。 产生式规则，看起来简单，却是一个水很深的领域，早期的人工智能和应用着重&#xA;研究专家系统，而产生式系统是专家系统的基石。不过往简单的方面来考虑，使用决策树&#xA;来做产生式规则还是很直观的。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>在TinyCore中取代BusyBox</title>
      <link>http://www.archs.tk/TinyCore/fullpowerTinyCore/</link>
      <pubDate>2013-04-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;TinyCore为了最小化体积，使用BusyBox构建基本的Shell环境，所以不是&#xA;完全的 &lt;code&gt;GNU compatible&lt;/code&gt; ，在编译软件的时候可能造成一定的困扰。如果&#xA;在TinyCore下面编译软件遇到问题，可注意下兼容性问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tce-load -wo coreutils util-linux&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以OnDemand的方式安装 &lt;code&gt;coreutils&lt;/code&gt; 和 &lt;code&gt;util-linux&lt;/code&gt; ，下载必须软件包。&#xA;使用的时候&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tce-load -i coreutils util-linux&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;即可。参见&lt;a href=&#34;http://tinycorelinux.net/faq.html#compatibility&#34;&gt;TinyCore Wiki&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用hg访问git仓库</title>
      <link>http://www.archs.tk/python/hg4git/</link>
      <pubDate>2013-04-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;hg用久了，觉得git命令很别扭，高级功能很少用到，速度差别基本上&#xA;感觉不出来，哈，所以还是hg喽. 唯一的问题就在于Github，它不支持hg。&#xA;好在hg有一个hggit的扩展，有一次感叹一下python的“batter included”！&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;安装前准备&#34; href=&#34;#安装前准备&#34;&gt;&lt;/a&gt;安装前准备&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Linux下面自然不用多说，Windows下面要注意几个问题&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除Mercurial提供的exe或者mis安装过的独立版本&lt;/li&gt;&#xA;&lt;li&gt;安装有Mingw，当然你用msvc的话下面的就可以省略了，&#xA;不过我还没有尝试过&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;设置Python Disutils的默认编译器为Gcc&#xA;进入 &lt;code&gt;PYTHON_HOME/Lib/distutils&lt;/code&gt; 建立新文件 &lt;code&gt;distutils.cfg&lt;/code&gt; 。&#xA;输入以下内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[build]&#xA;compiler=mingw32&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;安装&#34; href=&#34;#安装&#34;&gt;&lt;/a&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装就简单了，使用 &lt;code&gt;easy_install&lt;/code&gt; 或者 &lt;code&gt;pip&lt;/code&gt; 直接&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pip install mercurial&#xA;pip install hg-git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后配置hg加载hggit扩展，在用户目录下的 &lt;code&gt;.hgrc&lt;/code&gt; 文件中加入&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[extensions]&#xA;bookmarks =&#xA;hggit =&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后输入 &lt;code&gt;hg help&lt;/code&gt; 就能看看到hggit已加载的输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;enabled extensions:&#xA;&#xA;hggit         push and pull from a Git server&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用&#34; href=&#34;#使用&#34;&gt;&lt;/a&gt;使用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用的时候就是普遍的hg的命令了，这是相当happy的。&#xA;要注意的是git路径到hggit的转换，比如github中ssh方式访问&#xA;&lt;code&gt;git@github.com:username/reposname.git&lt;/code&gt; 要换成&#xA;&lt;code&gt;git+ssh://git@github.com:username/reposname.git&lt;/code&gt; 就可以了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;还有一个推送已有hg库到git库的方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cd hg-git # (a Mercurial repository)&#xA;$ hg bookmark -r default master # make a bookmark of master for default, so a ref gets created&#xA;$ hg push git+ssh://git@github.com/schacon/hg-git.git&#xA;$ hg push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;enjoy-you-git-now!&#34; href=&#34;#enjoy-you-git-now!&#34;&gt;&lt;/a&gt;Enjoy you Git Now!&lt;/h1&gt;&#xA;</description>
    </item>
    <item>
      <title>Embed ChickenScheme In Go</title>
      <link>http://www.archs.tk/go/goschicken/</link>
      <pubDate>2013-04-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用cgo加载c库的主要麻烦在于cgo不识别c头文件中的宏&#xA;而chicken scheme初始化的时候要调用一个全局函数CHICKEN_default_toplevel。&#xA;在cgo中使用 &lt;code&gt;void* dfp = CHICKEN_default_toplevel;&lt;/code&gt; 可以直接声明。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;/*&#xA;#cgo windows CFLAGS: -D_GUN_SOURCE -I&amp;quot;c:/my-chicken/include/chicken&amp;quot; -DHAVE_CHICKEN_CONFIG_H -DC_ENABLE_PTABLES&#xA;#cgo windows LDFLAGS: -L&amp;quot;c:/my-chicken/lib&amp;quot; -lchicken -lm&#xA;&#xA;#include &amp;lt;chicken.h&amp;gt;&#xA;&#xA;void* dfp = CHICKEN_default_toplevel;&#xA;*/&#xA;import &amp;quot;C&amp;quot;&#xA;import (&#xA;    &amp;quot;unsafe&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src := &amp;quot;(+ 1 2 3)&amp;quot;&#xA;    nSrc := 10&#xA;    ret := make([]byte, nSrc)&#xA;    p := (*C.char)(unsafe.Pointer(&amp;amp;ret[0]))&#xA;    C.CHICKEN_run(C.dfp)&#xA;    C.CHICKEN_eval_string_to_string(C.CString(src), p, C.int(nSrc))&#xA;    println(string(ret))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最近才发现，cgo不仅可以识别注释中的c语句，对于相同目录下面的*.c文件也可&#xA;自动编译，呵呵，像sqlite之类的库就可以静态的形式直接使用了。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Markdown</title>
      <link>http://www.archs.tk/utils/aboutMarkDown/</link>
      <pubDate>2013-03-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;感觉比rst简单许多，链接的使用也没有那么多的麻烦。&#xA;docutils是一个伟大的工具，但是有些 &lt;em&gt;繁琐&lt;/em&gt; 。细节的使用上&#xA;比如插入图片，虽然可以定制格式但是调整起来还是很麻烦的。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;简单的列表&#34; href=&#34;#简单的列表&#34;&gt;&lt;/a&gt;简单的列表&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;关键是列表啊，md的列表很比rst好用一些&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;这是itme1&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可插入一个段落，作为itme1的一个子段落，&#xA;这在rst中让我遇到很多麻烦&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Item2&lt;/p&gt;&#xA;&#xA;&lt;p&gt;rst中的ordered list不能够被自段落分开，否则编号不连续&#xA;最后使用的还是手写编号的形式，就跟md一样了&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;方便的标题&#34; href=&#34;#方便的标题&#34;&gt;&lt;/a&gt;方便的标题&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;标题要简洁一些，而且没有要求下划线至少要不标题长，少了一些约束。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;代码插入&#34; href=&#34;#代码插入&#34;&gt;&lt;/a&gt;代码插入&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;来段代码吧 :)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// New in version 2.6.&#xA;func PyErr_WarnPy3k(message string, stacklevel int) error {&#xA;    c_message := C.CString(message)&#xA;    defer C.free(unsafe.Pointer(c_message))&#xA;&#xA;    return int2err(C._gopy_PyErr_WarnPy3k(c_message, C.int(stacklevel)))&#xA;}&#xA;&#xA;// int PyErr_CheckSignals()&#xA;// This function interacts with Python’s signal handling. It checks whether a signal has been sent to the processes and if so, invokes the corresponding signal handler. If the signal module is supported, this can invoke a signal handler written in Python. In all cases, the default effect for SIGINT is to raise the KeyboardInterrupt exception. If an exception is raised the error indicator is set and the function returns -1; otherwise the function returns 0. The error indicator may or may not be cleared if it was previously set.&#xA;func PyErr_CheckSignals() bool {&#xA;    return int2bool(C.PyErr_CheckSignals())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;markdown跟HTML的紧密结合，使网页的手动写作方便了许多。虽然在多种到处格式上比&#xA;rst还是有些差距，但是用的机会毕竟不多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;想看教程的猛击这里&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown中文版语法说明&lt;/a&gt; :)&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>